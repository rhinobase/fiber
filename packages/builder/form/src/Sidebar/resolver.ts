import type { BaseBlockType, BaseBlockWithIdType } from "@fibr/providers";
import type { ThreadType } from "@fibr/react";
import { DEFAULT_GROUP, groupByParentNode } from "@fibr/shared";

export function reactHookFormResolver(
  schema: Record<string, BaseBlockType | undefined>,
) {
  const blocks = Object.entries(schema).reduce<BaseBlockWithIdType[]>(
    (prev, [id, value]) => {
      if (value) prev.push({ id, ...value });
      return prev;
    },
    [],
  );

  const group = groupByParentNode(blocks);
  const form = group[DEFAULT_GROUP]?.[0];

  if (!form) return "";

  const capitalizedTitle = formatTitle(form.title as string);
  const fields = group[form.id];

  const defaultValues = fields
    ?.reduce<string[]>((prev, { id, ...field }) => {
      if (field?.defaultValue == null) return prev;

      const { type, defaultValue } = field;

      prev.push(
        `${id}: ${type === "number" ? `${defaultValue}` : `"${defaultValue}"`}`,
      );

      return prev;
    }, [])
    .join(`\n${" ".repeat(6)}`);

  return `// Generated by fibr ${new Date().getFullYear()}
// Check it out at https://fibr.rhinobase.io

import z from "zod";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { FieldControl, Label, InputField, Textarea, ErrorMessage, Tooltip, TooltipTrigger, TooltipContent } from "@rafty/ui";

export const schema = z.object({
  ${fields?.map(({ id, ...field }) => generateZodSchema(id, field)).join(`\n${" ".repeat(2)}`)}
});

// Generated ${capitalizedTitle} form
export function ${capitalizedTitle}Form() {
  const {
    handleSubmit,
    register,
    formState: { errors, isSubmitting },
  } = useForm<z.infer<typeof schema>>({
    resolver: zodResolver(schema),${defaultValues ? `\n${" ".repeat(4)}${defaultValues}` : ""}
  });

  return (
    <form
      onSubmit={handleSubmit(console.log, console.error)}
      className="space-y-3"
    >
      ${fields
        ?.map(({ id, ...field }) => generateFieldComponent(id, field))
        .join(`\n${" ".repeat(6)}`)}
      <Button isLoading={isSubmitting} type="submit" colorScheme="primary">
        Submit
      </Button>
    </form>
  );
}`;
}

const formatTitle = (s: string) =>
  (s[0].toUpperCase() + s.slice(1)).replace(" ", "");

const generateZodSchema = (name: string, field?: ThreadType) => {
  const validationType = field?.type === "number" ? "number" : "string";

  return `${name}: z.${validationType}(),`;
};

const generateFieldComponent = (name: string, field?: ThreadType) => {
  if (!field) return "";

  const {
    type,
    label,
    required,
    hidden,
    disabled,
    placeholder,
    tooltip,
    description,
  } = field;

  const props = [];

  if (required) props.push("isRequired");
  if (disabled) props.push("isDisabled");
  if (hidden) props.push("hidden");
  if (tooltip) props.push(`tooltip="${tooltip}"`);

  return generateTooltip(
    `<FieldControl name="${name}"${props.length > 0 ? ` ${props.join(" ")}` : ""}>
        <Label>${label}</Label>
        ${description ? `<Text className="text-xs font-medium leading-[10px]" isMuted>${description}</Text>` : "\r"}
        <${type === "textarea" ? "Textarea" : "InputField"} {...register("${name}")}${placeholder ? ` placeholder="${placeholder}"` : ""} />
        <ErrorMessage>{errors.${name}?.message as string}</ErrorMessage>
      </FieldControl>`,
    tooltip,
  );
};

function generateTooltip(content: string, tooltip: unknown) {
  if (!tooltip) return content;

  return `<Tooltip>
    <TooltipTrigger>
      ${content}
    </TooltipTrigger>
    <TooltipContent>
      ${tooltip}
    </TooltipContent>
  </Tooltip>`;
}
